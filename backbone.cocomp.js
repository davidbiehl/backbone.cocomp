// Generated by CoffeeScript 1.6.3
/*! 
Backbone.CoComp v0.0.5
(c) 2013 David Biehl
Backbone.CoComp may be freely distributed under the MIT license.
For all details and documentation:
https://github.com/davidbiehl/backbone.cocomp
*/


(function() {
  var __slice = [].slice;

  Backbone.CoComp = (function() {
    _.extend(CoComp.prototype, Backbone.Events);

    function CoComp(opts) {
      if (opts == null) {
        opts = {};
      }
      this._collections = {};
      this.comparator = opts.comparator || (function() {
        throw "The CoComp requires a comparator";
      })();
    }

    CoComp.prototype.set = function(name, collection, options) {
      var old;
      if (options == null) {
        options = {};
      }
      if (name === 0 || name === 1) {
        throw "" + name + " is a reserved collection name, please use a different name";
      }
      old = this.get(name);
      if (old) {
        this.stopListening(old);
      }
      this._collections[name] = collection;
      this.listenTo(collection, 'reset', this.compare);
      this.listenTo(collection, 'add', this._onAdd);
      this.listenTo(collection, 'remove', this._onRemove);
      if (!options.silent) {
        return this.compare(name);
      }
    };

    CoComp.prototype.get = function(name) {
      return this._collections[name];
    };

    CoComp.prototype.unset = function(name, options) {
      if (options == null) {
        options = {};
      }
      if (!this.get(name)) {
        return;
      }
      if (!options.silent) {
        this.compare(name, {
          reverse: true
        });
      }
      return delete this._collections[name];
    };

    CoComp.prototype.compare = function() {
      var a, aName, b, bName, comparable, compared, names, options, _i, _ref, _results;
      names = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), options = arguments[_i++];
      if (options == null) {
        options = {};
      }
      if (!_.isObject(options)) {
        names.push(options);
        options = {};
      }
      compared = [];
      comparable = function(aName, bName) {
        return aName !== bName && (names.length === 0 || _.contains(names, aName) || _.contains(names, bName)) && !(_.findWhere(compared, {
          aName: bName,
          bName: aName
        }));
      };
      _ref = this._collections;
      _results = [];
      for (aName in _ref) {
        a = _ref[aName];
        _results.push((function() {
          var _ref1, _results1;
          _ref1 = this._collections;
          _results1 = [];
          for (bName in _ref1) {
            b = _ref1[bName];
            if (comparable(aName, bName)) {
              compared.push({
                aName: aName,
                bName: bName
              });
              _results1.push(this._compareCollections(a, b, {
                aName: aName,
                bName: bName,
                reverse: options.reverse
              }));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    CoComp.prototype._compareCollections = function(a, b, options) {
      var aName, bName,
        _this = this;
      if (options == null) {
        options = {};
      }
      aName = options.aName || this._collectionName(a);
      bName = options.bName || this._collectionName(b);
      if (!_.has(options, 'invert')) {
        options.invert = true;
      }
      if (aName !== bName) {
        a.forEach(function(aModel) {
          return _this._compareModelToCollection(aModel, b, {
            modelCollectionName: aName,
            collectionName: bName,
            reverse: options.reverse
          });
        });
        if (options.invert) {
          return this._compareCollections(b, a, {
            aName: bName,
            bName: aName,
            invert: false
          });
        }
      }
    };

    CoComp.prototype._compareModelToCollection = function(aModel, b, options) {
      var aName, bName, inCollection, inEvent,
        _this = this;
      if (options == null) {
        options = {};
      }
      aName = options.modelCollectionName || this._collectionName(aModel.collection);
      bName = options.collectionName || this._collectionName(b);
      if (aName !== bName) {
        if (options.reverse) {
          inEvent = "cocomp:out";
        } else {
          inEvent = "cocomp:in";
        }
        inCollection = false;
        b.forEach(function(bModel) {
          var exists;
          exists = _this._compareOne(aModel, bModel, inEvent, {
            aName: aName,
            bName: bName
          });
          return inCollection = inCollection || exists;
        });
        if (!inCollection) {
          aModel.trigger("cocomp:out:" + bName);
          return aModel.trigger("cocomp:out");
        }
      }
    };

    CoComp.prototype._compareOne = function(a, b, event, options) {
      var aName, bName, obj;
      if (options == null) {
        options = {};
      }
      aName = options.aName || this._collectionName(a.collection);
      bName = options.bName || this._collectionName(b.collection);
      obj = {};
      obj[aName] = obj[0] = a;
      obj[bName] = obj[1] = b;
      if (this.comparator.call(this.comparator, obj)) {
        b.trigger("" + event + ":" + aName, a);
        b.trigger("" + event, a);
        return true;
      } else {
        return false;
      }
    };

    CoComp.prototype._collectionName = function(collection) {
      var c, cName, _ref;
      _ref = this._collections;
      for (cName in _ref) {
        c = _ref[cName];
        if (c === collection) {
          return cName;
        }
      }
    };

    CoComp.prototype._onAdd = function(aModel) {
      var b, bName, _ref, _results;
      _ref = this._collections;
      _results = [];
      for (bName in _ref) {
        b = _ref[bName];
        _results.push(this._compareModelToCollection(aModel, b, {
          collectionName: bName
        }));
      }
      return _results;
    };

    CoComp.prototype._onRemove = function(aModel) {
      var b, bName, _ref, _results;
      _ref = this._collections;
      _results = [];
      for (bName in _ref) {
        b = _ref[bName];
        _results.push(this._compareModelToCollection(aModel, b, {
          collectionName: bName,
          reverse: true
        }));
      }
      return _results;
    };

    return CoComp;

  })();

}).call(this);
